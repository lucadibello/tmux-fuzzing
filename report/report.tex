\documentclass[11pt,a4paper,twocolumn]{article}

% Title and authors
\title{%
  CS-412 Software Security Lab 2\\[0.5em]
  \Large Fuzzing Lab Report\\
  Spring Semester 2025\\[0.5em]
  Project: Tmux
}

\author{%
  Luca Di Bello (SCIPER 367552)
  Federico Villa (SCIPER 386986) \\
  Noah El Hassanie (SCIPER 404885)
  Cristina Morad (SCIPER 405241) \\
}
\date{Submitted: May 15, 2025}

% Load custom styl
\usepackage{report_style}
\usepackage{minted} 

\begin{document}
\maketitle

\begin{abstract}
    In this lab, we improve the fuzzing efforts of the \texttt{tmux} terminal
    multiplexer within Google's OSS-Fuzz infrastructure. We first establish a
    baseline by evaluating the line coverage of the existing \texttt{input-fuzzer}
    harness, both with and without its provided seed corpus, obtaining comparable results.

    Following this, we identify two significant code regions in \texttt{tmux} uncovered
    by the baseline fuzzer. To address these coverage gaps, we develop
    and evaluate two new targeted fuzzing harnesses named \texttt{cmd-fuzzer}
    and \texttt{argument-fuzzer}, demonstrating their ability to improve coverage in these
    previously under-tested areas. As these specific fuzzing improvements did not uncover
    new critical vulnerabilities within the project's timeframe, our crash analysis
    focuses on a known historical vulnerability. We develop a proof-of-concept for
    CVE-2020-27347, a stack-based buffer overflow, proceed to analyze its
    root cause, discuss the implemented fix, and assess its overall security implications.
\end{abstract}

\section*{Introduction}
\label{sec:introduction}

Fuzzing is a proven technique to uncover memory security and logic bugs in
C/C++ code. In this assignment, we chose \texttt{tmux}, an open source terminal
multiplexer for Unix-like systems, as our target because it (1) has a relatively
small OSS-Fuzz integration (only one harness), (2) shows very low runtime
coverage, and (3) is widely used daily by developers and DevOps engineers across
countless systems. By improving its fuzzing harness, we aim both to increase
\texttt{tmux}'s coverage under OSS-Fuzz and to demonstrate how targeted harness
modifications can uncover real bugs in a piece of critical infrastructure.

\section*{Methodology}
\label{sec:methodology}

All experiments were performed on a Debian system with Linux kernel 6.1 (LTS),
Docker 28.1.1, and Python 3.11. We used a local fork of OSS-Fuzz located at
\texttt{forks/oss-fuzz}. To manage the various fuzzing campaigns for this project we implemented a unified and configurable scripting framework  All individual run scripts -- baseline evaluations for Part 1, and improved fuzzer runs for Part 3 -- share the same core script that handles the common fuzzing workflow. This core script's operational sequence, including environment preparation, building, fuzzing, and reporting, is detailed in the subsections below.

\noindent \paragraph{Configuration} \label{sec:methodology_configuration} The script is highly configurable via environment variables set at the top. Key configuration variables include:
\begin{itemize}
	\item \texttt{PROJECT=tmux} -- OSS-Fuzz project name.
	\item \texttt{HARNESS=input-fuzzer} -- name of the project's fuzzing harness to run.
	\item \texttt{ENGINE=libfuzzer} -- engine to use. The tmux project supports \texttt{libfuzzer}, \texttt{afl++}, and \texttt{honggfuzz} \cite{oss-fuzz:tmux_project_yaml}.
	\item \texttt{SANITIZER=address} -- Sanitizer to use. The tmux project supports \texttt{address} (ASan), \texttt{undefined} (UBSan), or \texttt{none} (disabled) \cite{oss-fuzz:tmux_project_yaml}.
	\item \texttt{RUNTIME=14400} -- fuzzing time in seconds (by default 4 hours).
	\item \texttt{LABEL} -- A unique label for the run (e.g., \texttt{w\_corpus}, \texttt{wo\_corpus}) used for naming output files.
	\item \texttt{REBUILD\_IMAGE=true} -- controls whether to rebuild the OSS-Fuzz Docker image from scratch.
	\item \texttt{PATCH\_FILE} -- Optional path to a patch file to apply.
	\item \texttt{EXPORT\_RESULTS=true} -- Controls whether to export the generated corpus and coverage report after the fuzzing run.
	\item \texttt{LIBFUZZER\_FLAGS} -- Fuzzer engine flags (e.g., \texttt{-max\_total\_time=\$RUNTIME -ignore\_crashes=1}). This flag is used to override the default harness-specific options (e.g. \texttt{.option} files)
\end{itemize}

The script derives several other internal path variables based on these configurations.

\noindent \paragraph{Setup and Patching} \label{sec:methodology_setup_patching}

Before performing any builds or fuzzing, the script ensures a clean and correctly configured OSS-Fuzz environment.

\begin{itemize}
	\item If the local OSS-Fuzz clone does not exist at \texttt{\$OSS\_FUZZ\_DIR}, it is cloned from \href{https://github.com/google/oss-fuzz.git}{github.com/google/oss-fuzz}.
	\item The script navigates into the \texttt{\$OSS\_FUZZ\_DIR} and performs a hard reset and clean (\texttt{git reset --hard HEAD \&\& git clean -fdx}) to discard any previous modifications and ensure a clean state.
	\item A mandatory patch, \texttt{oss-fuzz.diff}, located alongside the script in \texttt{\$SCRIPT\_DIR}, is applied to the root of the OSS-Fuzz repository. This patch contains baseline modifications required for the experiments, such as potential adjustments to the project's \texttt{Dockerfile} and \texttt{build.sh}.
	\item If the \texttt{PATCH\_FILE} variable is set and the file exists, this optional patch is applied.
\end{itemize}

This flexible patching mechanism allows the single script to handle configurations like unseeded runs, where a patch is needed to modify the build process to exclude the seed corpus.

\noindent \paragraph{Clean build directory} \label{sec:methodology_clean} If \texttt{\$REBUILD\_IMAGE} is true, the script removes the entire \texttt{\$OSS\_FUZZ\_DIR/build} directory:
\begin{lstlisting}[language=bash, caption={Bash script to clean the OSS-Fuzz build directory with error handling}]
rm -rf "$OSS_FUZZ_DIR/build" || true
\end{lstlisting}

This ensures no stale build artifacts remain from previous runs and that the Docker image build process starts from a clean slate. Additionally, the script ensures the fuzzer artifact directory exists by creating it if necessary (located at \texttt{\$OSS\_FUZZ\_DIR/build/out/\$PROJECT/crashes}).

\begin{lstlisting}[language=bash, caption={Bash script to apply the patch to remove the seed corpus from the Docker image and build script}]
git apply part_1/
  remove_seed_corpus.patch
\end{lstlisting}

\noindent \paragraph{Build OSS-Fuzz image and fuzzers} \label{sec:methodology_build} To prepare the fuzzing environment, the script uses the OSS-Fuzz helper script \texttt{infra/helper.py}.

Before building the Docker image, the script checks the \texttt{\$REBUILD\_IMAGE} variable. If set to \texttt{true}, the following command is executed within \texttt{\$OSS\_FUZZ\_DIR} to build the Docker image for the configured project:

\begin{lstlisting}[language=bash, caption={Bash script to build the Docker image for the configured project}]
python3 infra/helper.py build_image "$PROJECT" --pull
\end{lstlisting}
The \texttt{---pull} flag ensures the latest OSS-Fuzz base image is used.

Regardless of the \texttt{\$REBUILD\_IMAGE} variable, the script always rebuilds the fuzzers with the specified sanitizer using the following command:
\begin{lstlisting}[language=bash, caption={OSS-Fuzz helper script command to build the project fuzzers with the specified sanitizer}]
python3 infra/helper.py build_fuzzers "$PROJECT" --sanitizer "$SANITIZER"
\end{lstlisting}
This compiles the fuzzers and instruments them with the selected sanitizer. The resulting binaries are placed in \texttt{\$OSS\_FUZZ\_DIR/build/out/\$PROJECT}.

\noindent \paragraph{Corpus Preparation for Build} \label{sec:methodology_corpus_prep_build} The tmux build process populates the directory \texttt{\$OSS\_FUZZ\_DIR/build/work/\ \$PROJECT/fuzzing\_corpus} with the seed corpus, if available.

To ensure that unseeded runs start without initial data, the script checks the \texttt{REMOVE\_CORPUS\_BEFORE\_BUILD} variable. If true (as it would be for an unseeded configuration), the script removes this directory before the fuzzer build step to ensure a clean state. This is done using the following command:

\begin{lstlisting}[language=bash, caption=Bash command to remove the build-time corpus directory for unseeded runs]
rm -rf "$BUILD_WORK_CORPUS_DIR"
\end{lstlisting}

For seeded runs, this variable would be set to \texttt{false}, allowing the build process to populate the directory with the seed corpus.

\noindent \paragraph{Run the fuzzer} \label{sec:methodology_run}

To start the fuzzing campaign, the script uses the \texttt{run\_fuzzer} command from the OSS-Fuzz helper script. The input corpus directory used by the fuzzer is \texttt{\$BUILD\_WORK\_CORPUS\_DIR}, which was computed in the previous steps. The fuzzer runs for the time specified by \texttt{\$RUNTIME}.

\begin{lstlisting}[language=bash, caption=Bash command to run a single fuzzing campaign leveraging OSS-Fuzz helper script]
python3 infra/helper.py run_fuzzer \
  --engine "$ENGINE" \
  --corpus-dir "$BUILD_WORK_CORPUS_DIR" \
  "$PROJECT" "$HARNESS" -- \
  "$LIBFUZZER_FLAGS"
\end{lstlisting}

The configured flags from \texttt{\$LIBFUZZER\_FLAGS}, such as \texttt{-ignore\_crashes=1} to continue fuzzing after finding crashes and \texttt{-artifact\_prefix=./crashes/} to store crashes in the designated subdirectory (relative to the fuzzer's working directory, which is handled by \texttt{helper.py}), are passed to the fuzzer engine.

\noindent \paragraph{Export Results (Corpus and Coverage)} \label{sec:methodology_export}

If the \texttt{EXPORT\_RESULTS} variable is set to \texttt{true}, the script exports both the generated corpus and the coverage report. A timestamp (\texttt{\$TS}) and the run's label (\texttt{\$LABEL}) are included in the output filenames for identification.

\emph{Corpus Export:} The contents of the fuzzer's working corpus directory (\texttt{\$BUILD\_WORK\_CORPUS\_DIR}) are copied to a timestamped and labeled directory within \texttt{\$CORPUS\_EXPORT\_DIR\_BASE}. This directory is then compressed into a zip archive, and the original copied directory is removed.

\begin{lstlisting}[language=bash, caption=Bash commands to export and zip the generated corpus]
cp -r "${BUILD_WORK_CORPUS_DIR}" "${FINAL_CORPUS_EXPORT_PATH}"
(cd "$(dirname "${FINAL_CORPUS_EXPORT_PATH}")" && \
 zip -qr "${FINAL_CORPUS_EXPORT_PATH}.zip" \
 "$(basename "${FINAL_CORPUS_EXPORT_PATH}")" && \
 rm -rf "${FINAL_CORPUS_EXPORT_PATH}")
\end{lstlisting}

\emph{Coverage Report Generation and Export:} To generate the coverage report, the fuzzers are first rebuilt with the \texttt{coverage} sanitizer enabled using \texttt{helper.py build\_fuzzers}. Then, the \texttt{helper.py coverage} command is executed within \texttt{\$OSS\_FUZZ\_DIR}, specifying the generated corpus directory (\texttt{\$BUILD\_WORK\_CORPUS\_DIR}) and the target harness.

\begin{lstlisting}[language=bash, caption=Bash commands to rebuild with coverage and generate report]
python3 infra/helper.py build_fuzzers --sanitizer coverage "$PROJECT"
python3 infra/helper.py coverage \
  --corpus-dir "$BUILD_WORK_CORPUS_DIR" \
  --fuzz-target "$HARNESS" \
  "$PROJECT" &
\end{lstlisting}
The coverage command runs in the background. The script then polls the expected output directory (\texttt{\$OSS\_FUZZ\_DIR/build/out/\$PROJECT/report}) for up to 5 minutes, waiting for the report files to appear. Once generated or the timeout is reached, any background processes and Docker containers associated with the coverage generation are explicitly stopped. Finally, the generated HTML report directory is copied to a timestamped and labeled directory within \texttt{\$COVERAGE\_EXPORT\_DIR\_BASE}, compressed into a zip archive, and the copied directory is removed (same technique as with the corpus export). After completing these steps, the script changes back to the original experiment root directory.

\section*{Part 1: Baseline Evaluation}

\subsection*{With Seed Corpus} \label{sec:with-seed}

We ran a 4-hour fuzzing campaign using the predefined \texttt{input-fuzzer} harness and the official tmux seed corpus, with \texttt{libfuzzer} as the fuzzing engine and \texttt{AddressSanitizer} enabled. This configuration corresponds to the default parameters outlined in the \emph{Methodology} section.

The entire process, from Docker image preparation to fuzzer execution and coverage report generation, is fully automated by the script \texttt{run\_w\_corpus.sh}, located in \texttt{submission/part\_1}. This script is intended to be run from the submission folder root and performs automatically all required steps.

\begin{lstlisting}[language=bash, caption=Bash command to run an automated fuzzing campaign with seed corpus]
part_1/run.w_corpus.sh
\end{lstlisting}

The seeded fuzzing campaign completed successfully and produced the following coverage results, summarized in \autoref{tbl:coverage-w-corpus}.

\begin{table}[ht]
	\centering
	\begin{tabular}{@{}ll@{}}
		\toprule
		\textbf{Metric}   & \textbf{Coverage}    \\
		\midrule
		Line Coverage     & 14.00\% (7281/51997) \\
		Function Coverage & 24.44\% (558/2283)   \\
		Region Coverage   & 13.41\% (5481/40874) \\
		\bottomrule
	\end{tabular}
	\caption{Coverage with seed corpus after a 4-hour fuzzing run.}
	\label{tbl:coverage-w-corpus}
\end{table}

\subsection*{Without Seed Corpus} \label{sec:without-seed}

To ensure comparable results between the two runs, we used the same configuration, including the fuzzing engine, harness, and sanitizer. The only difference between the two campaigns is that we removed the seed corpus from build script by applying the patch \texttt{remove\_seed\_corpus.patch} using the \texttt{git apply} utility,and ran the fuzzing with an empty seed corpus directory. For more information on how the seed corpus was excluded, refer to \autoref{sec:methodology_setup_patching}.

Similarly as the seeded run script, the unseeded run script is designed to be run from the root of the project, and it takes care of all necessary steps, including building the patched Docker image, compiling the fuzzers, running the fuzzing campaign, and generating the coverage report:

\begin{lstlisting}[language=bash, caption=Bash command to run an automated fuzzing campaign without seed corpus]
part_1/run.wo_corpus.sh
\end{lstlisting}

The unseeded fuzzing campaign completed successfully and produced the following coverage results, summarized in \autoref{tbl:coverage-wo-corpus}.

\begin{table}[ht]
	\centering
	\begin{tabular}{@{}ll@{}}
		\toprule
		\textbf{Metric}   & \textbf{Coverage}    \\
		\midrule
		Line Coverage     & 13.94\% (7248/51997) \\
		Function Coverage & 24.31\% (555/2283)   \\
		Region Coverage   & 13.35\% (5457/40874) \\
		\bottomrule
	\end{tabular}
	\caption{Coverage without seed corpus after a 4-hour fuzzing run.}
	\label{tbl:coverage-wo-corpus}
\end{table}

The results are very similar to those obtained with the seed corpus, with only minor differences across all metrics. This suggests that the fuzzer is able to reach most of the currently covered code paths even without initial inputs. A detailed comparison of both runs is provided in the next section.

\subsection*{Coverage Comparison}
\label{sec:coverage-comparison}

\autoref{tbl:coverage-comparison} summarizes the per-file differences in coverage between the two fuzzing runs, with and without the seed corpus. The table shows the percentage of lines covered by the fuzzer in each file, along with the difference in coverage between the two runs. Since the coverage is very sparse, we only show the files with at least 0.5\% coverage in either run.

\begin{table*}[!tb]  % two-column float, top or bottom only
	\centering
	\scriptsize
	\setlength{\tabcolsep}{4pt}    % a bit narrower columns
	\renewcommand{\arraystretch}{1.1}

	\begin{tabular}{@{}lrrr@{}}     % ordinary, non-splitting table
		\toprule
		Path                                &
		Cov\_$\text{wo}$ (\%)               &
		Cov\_$\text{w}$ (\%)                &
		$\Delta$ (\%)                                              \\
		\midrule
		src/tmux/alerts.c                   & 15.18 & 15.18 & 0.00 \\
		src/tmux/arguments.c                & 5.82  & 5.82  & 0.00 \\
		src/tmux/cmd-find.c                 & 6.54  & 6.54  & 0.00 \\
		src/tmux/cmd-parse.c                & 26.95 & 26.95 & 0.00 \\
		src/tmux/cmd-queue.c                & 21.25 & 21.25 & 0.00 \\
		src/tmux/cmd.c                      & 26.70 & 26.70 & 0.00 \\
		\rowcolor{yellow} src/tmux/colour.c & 70.38 & 70.78 & 0.40 \\
		src/tmux/compat/recallocarray.c     & 13.89 & 13.89 & 0.00 \\
		src/tmux/compat/strlcat.c           & 90.48 & 90.48 & 0.00 \\
		src/tmux/compat/strtonum.c          & 96.97 & 96.97 & 0.00 \\
		src/tmux/compat/tree.h              & 93.86 & 93.86 & 0.00 \\
		src/tmux/compat/vis.c               & 15.69 & 15.69 & 0.00 \\
		src/tmux/control-notify.c           & 8.28  & 8.28  & 0.00 \\
		src/tmux/format.c                   & 28.37 & 28.37 & 0.00 \\
		src/tmux/fuzz/input-fuzzer.c        & 93.88 & 93.88 & 0.00 \\
		src/tmux/grid-view.c                & 69.64 & 69.64 & 0.00 \\
		src/tmux/grid.c                     & 33.52 & 33.52 & 0.00 \\
		src/tmux/hyperlinks.c               & 81.25 & 81.25 & 0.00 \\
		\rowcolor{yellow} src/tmux/input.c  & 91.64 & 92.31 & 0.67 \\
		src/tmux/log.c                      & 8.54  & 8.54  & 0.00 \\
		src/tmux/notify.c                   & 49.30 & 49.30 & 0.00 \\
		src/tmux/options.c                  & 25.85 & 25.85 & 0.00 \\
		src/tmux/osdep-linux.c              & 12.73 & 12.73 & 0.00 \\
		\rowcolor{yellow} src/tmux/paste.c  & 36.67 & 38.33 & 1.66 \\
		src/tmux/screen-write.c             & 64.14 & 64.14 & 0.00 \\
		src/tmux/screen.c                   & 50.23 & 50.23 & 0.00 \\
		src/tmux/style.c                    & 27.27 & 27.27 & 0.00 \\
		src/tmux/utf8-combined.c            & 38.18 & 38.18 & 0.00 \\
		src/tmux/utf8.c                     & 26.85 & 26.85 & 0.00 \\
		\rowcolor{yellow} src/tmux/window.c & 14.40 & 15.46 & 1.06 \\
		src/tmux/xmalloc.c                  & 80.46 & 80.46 & 0.00 \\
		\bottomrule
	\end{tabular}

	\caption{Per-file line-coverage comparison between two \texttt{libfuzzer} runs (with and without a seed corpus) using the \texttt{input-fuzzer} harness compiled with \texttt{AddressSanitizer}.  Highlighted rows show differing coverage.}
	\label{tbl:coverage-comparison}
\end{table*}

From the summary tables in \autoref{tbl:coverage-w-corpus} and \autoref{tbl:coverage-wo-corpus} and the detailed comparison in \autoref{tbl:coverage-comparison}, we can observe the following key points
\begin{itemize}
	\item The overall coverage is very similar between the two runs, with only a few files showing differences in coverage.
	\item Introducing the seed corpus adds just a few dozen lines ($\approx$40 lines; $\approx$0.13\% change in regions/functions coverage).
	\item Across the entire codebase, the only difference in coverage are observed in the following files. All of them showcased a small increase in coverage with the seed corpus.

	      \begin{center}
		      \begin{tabular}{@{}r@{\hspace{1em}}l@{}}
			      \texttt{input.c:}  & 91.64\% $\rightarrow$ 92.31\% \\
			                         & $\Delta = 0.67$               \\[1.5ex]
			      \texttt{colour.c:} & 70.38\% $\rightarrow$ 70.78\% \\
			                         & $\Delta = 0.40$               \\[1.5ex]
			      \texttt{paste.c:}  & 36.67\% $\rightarrow$ 38.33\% \\
			                         & $\Delta = 1.66$               \\[1.5ex]
			      \texttt{window.c:} & 14.40\% $\rightarrow$ 15.46\% \\
			                         & $\Delta = 1.06$
		      \end{tabular}
	      \end{center}

	      The overall increase in coverage is minimal, but still provides some insight into the fuzzer's behavior.

	\item These small deltas confirm that the fuzzer is already able to reach most of the code paths in the \texttt{input.c} module, which is responsible for parsing and processing user input. The small increase in coverage in \texttt{colour.c}, \texttt{paste.c}, and \texttt{window.c} suggests that the seed corpus may help explore some additional code paths which are difficult to reach with random inputs alone (e.g. color combinations, paste buffer handling, window management).

	      As \texttt{tmux} is a hotkey-based terminal multiplexer, we expected to get high coverage results in both runs as, as soon as the fuzzer identifies a valid hotkey sequence, it can trigger a large number of code paths with minimal effort.

	\item Overall coverage remains low ($\sim$14\%), indicating large untested areas. By inspecting the full coverage reports, was discovered that \texttt{client.c}, \texttt{server.c}, and most \texttt{cmd-*.c} modules are not covered using the \texttt{input-fuzzer}, in fact their coverage is $0\%$ in the OSS-Fuzz generaed report.
\end{itemize}

\section*{Part 2: Coverage Gaps}

As cited in the previous section, the default fuzzing harness, \texttt{input-fuzzer}, is limited to the user-interface-level input parser, leaving multiple essential tmux components completely untested.

The current harness has a very narrow scope: it only executes low-level input parsing functions with most of the codebase remaining untested. Based on coverage reports from both with-corpus ($14.00\%$ line coverage, $24.44\%$ function coverage, $13.41\%$ region coverage) and without-corpus ($13.94\%$ line coverage, $24.31\%$ function coverage, $13.35\%$ region coverage) runs, we can see that only input parsing, color formatting code and command parsing areas are covered in the current harness.

Multiple components of the tmux codebase are quite complex and difficult to test under a fuzzer; for example all the code areas that require multiple processes or threads or the use of sockets. A prominent example of such complex regions is the \texttt{client} and \texttt{server} subsystem: when tmux is launched, it either connects to an existing server or spawns one. The server, as defined in \texttt{server.c}, is a background process that handles all active sessions, panes and windows. Each user terminal runs a client process, defined in \texttt{client.c}, that communicates with the server using a UNIX-domain socket. Other code areas that are similarly complex might require a multiplexer runtime environment or execution of multiple commands in a command line environment, therefore they might be harder to test at a high level.

Fuzzing these complex code areas would demand creating real sockets, forking processes, and simulating terminal inputs, all of which pushes typical fuzzers beyond practical limits. Mocking a socket or using other fake implementations was not considered, as it would have required testing the functions in isolation and maintaining a separate and complex implementation just to simulate each component. This approach deviates from realistic tmux execution and would therefore lack testing integration bugs that might happen during the communications between client and server. Therefore the original authors preferred to focus on low level code areas that are simpler, more deterministic and do not require complex environments.

Several code areas remain uncovered by the current fuzzing harness, such as:
\begin{itemize}
    \item Screen and grid management code responsible for handling drawing operations, scrolling, and clipping on each terminal update
    \item Layout computation code that calculates pane sizes and positions for various tmux layout strategies (main-horizontal, even-horizontal, tiled, etc.)
    \item Window management code (creation, destruction, and layout of tmux windows and their buffers)
    \item Terminal capabilities handling
    \item Style formatting
    \item Event handling mechanisms
\end{itemize}

Most of these code regions are areas where users are less likely to supply malformed inputs directly. Therefore, we decided to focus on areas that are primary gatekeepers for user-supplied inputs:

\begin{itemize}
	%\item Client-server communication (\texttt{client.c} and \texttt{server.c})
    \item Command-line argument handling (\texttt{arguments.c})
	\item Command execution, command parsing logic and individual command modules (\texttt{cmd-parse.c} and \texttt{cmd-*.c} modules)
\end{itemize}

This lack of coverage is expected, as the harness never initializes a real tmux client or server, nor does it establish any socket-based communication so it does not test the application end to end. Instead, \texttt{input-fuzzer} simply creates a mock window and pane in-memory, and feeds them raw byte sequences generated by the fuzzing engine, as shown in \autoref{lst:input-fuzzer}.

\begin{lstlisting}[language=C,caption={Core of the `input-fuzzer` fuzzer code, including in-memory window and pane creation},label={lst:input-fuzzer}]
// Initialize the window and pane
w = window_create(PANE_WIDTH, PANE_HEIGHT, 0, 0
);
wp = window_add_pane(w, NULL, 0, 0);

// ...

// Process input and handle any error event
input_parse_buffer(wp, (u_char *)data, size);
while (cmdq_next(NULL) != 0);
error = event_base_loop(libevent, EVLOOP_NONBLOCK);
if (error == -1) errx(1, "event_base_loop failed");
\end{lstlisting}

Because no real client or server binary ever runs, the initialization, connection‑handling, and command‑dispatch code in both \texttt{client.c} and \texttt{server.c} is never reached. Likewise, none of the \texttt{cmd-*.c} handlers (e.g. \texttt{cmd-new-window.c}, \texttt{cmd-split-window.c}) ever see fuzzed input via the normal client‑server path as they are not executed in this environment. The code in \texttt{arguments.c} that handles command-line arguments is also bypassed entirely, representing a significant vulnerable code area that remains untested in the current implementation.


\subsection*{Region A: \textit{Arguments}}

The \texttt{arguments.c} file implements tmux's command-line argument parsing and handling system. This component plays a critical role in tmux's functionality by:

\begin{itemize}
  \item Processing all command-line parameters passed when tmux is launched
  \item Managing socket paths, configuration files, and control mode settings
  \item Providing utilities to validate and convert argument values
  \item Creating structured argument collections used throughout the program
\end{itemize}

This module is particularly important for security testing because it directly processes untrusted user input. Command-line arguments represent a classic attack vector for exploitation, with potential for path traversal, buffer overflows, or format string vulnerabilities if input validation is insufficient.

Our analysis of the coverage reports confirms that the existing fuzzing harness achieves only about 5.8\% line coverage of \texttt{arguments.c}. Examining the harness code in \texttt{input-fuzzer.c} reveals several fundamental reasons for this limited coverage:

\begin{itemize}
  \item \textbf{Initialization architecture}: The fuzzer initializes a minimal tmux environment with just a window and pane object, bypassing the normal program entry point. In the \texttt{LLVMFuzzerInitialize} function, it creates basic global structures but never invokes the argument parser.
  
  \item \textbf{Input delivery method}: The fuzzer sends data directly to \texttt{input\_parse\_buffer()} rather than through the main command-line argument system. While some command parsing may indirectly invoke \texttt{args\_parse()}, the full structured command-line handling is not properly exercised.
  
  \item \textbf{Process lifecycle}: LibFuzzer's design maintains a persistent process, calling the \texttt{LLVMFuzzerTestOneInput} function repeatedly on the same process. However, command-line arguments are typically processed once during program initialization, making this model ineffective for testing argument handling.
  
  \item \textbf{Environment isolation}: The fuzzer runs in a controlled container environment without access to the filesystem or socket resources that many argument-handling functions interact with, leaving code paths like \texttt{args\_check\_socket()} and \texttt{args\_load\_cfg()} untested.
\end{itemize}

Looking at specific uncovered functions in the coverage reports, we observe that critical sections like \texttt{args\_parse()}, \texttt{args\_find()}, and \texttt{args\_escape()} show zero execution counts. Additionally, complex features such as the percentage-based size calculations in \texttt{args\_percentage()} remain completely unexplored by the fuzzer.

\subsection*{Region B: \textit{Command Parsing}}

The \texttt{cmd-parse.c} file implements tmux's command parser, which is responsible for converting textual commands into executable structures. This component:

\begin{itemize}
  \item Processes commands from interactive user input, configuration files, and scripts
  \item Handles complex language features including quoting, variable expansion, and command chaining
  \item Validates command syntax and semantics before execution
  \item Resolves targets for commands (session, window, and pane specifiers)
\end{itemize}

The command parser is a critical security boundary as it processes input from multiple sources including configuration files that may contain untrusted content. Vulnerabilities in this component could potentially lead to command injection or denial of service issues.

The command parse file is implemented in the code as a \textit{Yacc} (\textit{Yet Another Compiler Compiler}) parser file, so as a \texttt{cmd-parse.y} file that will be compiled into a \texttt{.c} file. The \texttt{cmd-parse.c} has some high level functions that interacts with and dispatches functionality to various \texttt{cmd-*.c} files, each of which implements a specific tmux command. Most of such specific command files are not touched by the current harness even though they represent some of the core operational logic of individual tmux commands and therefore could constitute a prime fuzzing target.

Our coverage analysis shows that despite \texttt{cmd-parse.c} having better coverage than most tmux components at approximately 27\% line coverage, significant portions remain untested. Examining the harness structure explains these gaps:

\begin{itemize}
  \item \textbf{Missing server context}: The existing harness establishes a basic pane and window environment but lacks the full server infrastructure. The coverage report reveals that code paths requiring interaction with server data structures (like session and client management) show zero execution counts.
  
  \item \textbf{Limited tokenization}: While the harness does invoke \texttt{input\_parse\_buffer()}, which eventually leads to some command parsing, the randomized fuzzing input rarely satisfies the tokenizer's grammar requirements. Examining uncovered regions in the report shows most advanced parsing features like variable expansion (\texttt{\$\{...\}}), escape sequences (line 3400-3404), and quoted strings (lines 3419-3438) are never executed.
  
  \item \textbf{Command structure limitations}: The harness creates a minimal command environment, but many commands in tmux expect to interact with other subsystems. For example, conditional command execution (\texttt{\%if} blocks) shows zero coverage in the report.
  
  \item \textbf{Tokenization barriers}: The parser's design expects structured input with properly quoted strings, escape sequences, and command chaining. From the coverage report, we can see that error paths like the ones at lines 3454-3457 are never reached because random inputs fail at earlier validation stages.
\end{itemize}

Even in more heavily covered sections of the file, the coverage is often limited to simple path validation without exploring deeper conditional branches. For instance, while the basic token reading loop (lines 3290-3448) shows some coverage, most of the specialized command handling branches within it remain untested.

\section*{Part 3: Fuzzer Improvements}

In this section we describe the modifications and additions made to the fuzzing infrastructure to improve the two (currently) uncovered regions identified in part 2.

\subsection*{Overview}

Improvements to the code coverage were achieved by targeting the two specific previously uncovered code regions with two new harnesses.

\subsection*{Improvement of Region A: \textit{Arguments}} 

This new harness tries to cover the \texttt{arguments.c} file which, as already explained in Part 2, is responsible for processing the command-line flags that are passed to the tmux executable. Given its importance and the fact that the old oss-fuzz harness has only a $5.82\%$ coverage on this file we decided to create a harness that specifically target this file.

To fuzz this file we created a completely new harness that tries to call as many functions as possible from this file. The first thing we do in this harness is to parse the bytes given by libfuzzer into 2 variables: \texttt{char **argv} and \texttt{int args}, which are the command-line arguments that are normally passed to a program. With these 2 variables we are able to call the function \texttt{args\_from\_vector} which will create a \texttt{struct args\_value *}. Subsequently we used this struct with a \texttt{struct args\_parse} (which we can create with the bytes given from libfuzzer) to call the 
\texttt{args\_parse} function which will return a \texttt{struct args *}. This struct is needed for many functions in the \texttt{arguments.c} file, e.g. we can use this struct together with bytes from libfuzzer to call \texttt{args\_print, args\_has, args\_get, args\_first, args\_count, args\_value,  args\_first\_value, args\_next\_value,  args\_string, args\_copy, args\_percentage, args\_strtonum}. Many of these functions allocate some space on the heap calling \texttt{malloc}, so if a function fails or we don't have enough bytes from libfuzzer to call the subsequent functions then we perform a cleanup calling \texttt{free} (or \texttt{args\_free}) to avoid the LeakSanitizer to give us some errors. 

To build the docker image, the harness and run the harness you should execute the script \texttt{run\_improve1.sh} from the root of this project.

This new harness reach a coverage of 66.62\% which is 60\% more than the previous harness. The previous harness didn't focus on working with the arguments so the only called functions were \texttt{args\_parse, args\_create, args\_free and args\_print}. Since our harness focuses on calling as more functions as possible from this file it's trivial to understand the reason why our harness covers much more region.

Further improvements for this file is to target the function \texttt{args\_make\_commands\_now} which, as the name suggests, is responsible for the execution of commands. This function could increase the coverage of this file by a lot, since it also calls other 3 functions in \texttt{arguments.c} (\texttt{args\_make\_commands\_prepare}, \texttt{args\_make\_commands} and \texttt{args\_make\_commands\_free}) that were not covered by our harness. We didn't target these functions because unlike the other functions that we targeted, these don't work with \texttt{struct args *} but instead with \texttt{struct cmd *} and \texttt{struct cmdq\_item *}.


\subsection*{Improvement of Region B: \textit{Command Parsing}}

The improvements of \textit{Region B} targets the parsing of user-provided arguments, command execution and command parsing logic in general. The target is a code area called when commands from the user input, configuration file  or command-line arguments are translated into structured commands for execution, therefore it's an area directly in contact with the user input. 

As the code inside \texttt{cmd-parse.c} is only covered partially in the current harness, and almost all of the other command specific files are not targeted (such as \texttt{cmd.c}, \texttt{key-bindings.c}, \texttt{cmd-bind-key.c}, \texttt{key-string.c}, ...), since their functions are never invoked, we decided to improve coverage in these areas. To achieve this, we added calls to several \texttt{cmd-parse.c} functions that are normally invoked during client creation, specifically in \texttt{client.c}. These functions are directly called by the user input, meaning that any input generated by the fuzzer can be  easily and reliably reproduced through a corresponding direct invocation of tmux. This gives the fuzzing test cases of improved area \textit{B} strong reproducibility.

The harness implementation consists of two main parts:
\begin{itemize}
    \item Transforming the fuzzer input into a valid input format for the command parser target function, by parsing it into an argument count \texttt{argc} and an argument vector \texttt{argv}.
    \item Crafting argument parsing tmux structures, creating commands and parsing them using \texttt{cmd\_parse\_from\_arguments}. To ensure reproducibility this parts is created taking inspiration from the command line parsing that happens inside the \texttt{client\_main} function, which uses directly the user-provided command line arguments. 

\end{itemize}
The call to \texttt{cmd\_parse\_from\_arguments} is a high level function that has lots of underlying new function calls. Therefore the fuzzer execution may branch into multiple \texttt{cmd-*.c} files, depending on the input provided. This because the \texttt{cmd\_parse\_from\_arguments} is the funciton responsible to parsing user-supplied command line arguments and therefore based on the specific command it handles control to the corresponding implementation file, so with that function call we can call a wide range of command-specific code paths in various \texttt{cmd-*.c} files.

In addition, the harness must initialize correctly global variables and free up all dynamically allocated data and struct to ensure the lack of errors or unexpected memory leaks.

To run the new harness two flags were added in the \texttt{cmd-fuzzer.options} file, the file containing the flags for the fuzzer (\textit{libFuzzer}). One of the flag is \texttt{detect\_leaks=0} and it pauses the leakage detection. The leakage detection was not taken into account, even if this causes missing memory leaks, because when running the new harness due to \texttt{cmd-parse.y} a memory leakage happens only after multiple runs due to the improper cleanup of the \texttt{static struct cmd\_parse\_state parse\_state} between successive parsing runs that triggers false positives in leak detection (as the leak detected in the Yacc parser file. These variables are static variables that retain state between parser invocations. This issue could be solved with either the new flag or by adding a Bison \href{https://www.gnu.org/software/bison/manual/html_node/Destructor-Decl.html}{\texttt{\%destructor} rule}.
Therefore leak checking was disabled to prioritize identifying critical crashes or bugs.
The other flag is an increase of the standard memory usage limit, \texttt{rss\_limit\_mb}, and it is added to avoid that an excessive use of memory (more than the standard \texttt{2048 MB} limit) causes the failure of libFuzzer.

To improve the fuzzing efficiency and guide libFuzzer input generation toward meaningful tmux command-line strings a dictionary file, \texttt{cmd-fuzzer.dict}, file was created. It contains tmux commands, options, aliases and flags commonly used (for example \texttt{"new-window", "split-window", "-h", ...}).

To build and run the new harness the script \texttt{run\_improve2.sh} should be executed; it clone and applies the adequate changes to the oss-fuzz repository such that the new harness is executed out of the box.

After fuzzing the project with the new harness three times for 4 hours, the line-coverage and function coverage of the key parsing and dispatch code increased in the areas we targeted: \texttt{cmd-parse.c} jumped by $13.89\%$ in function coverage to $77.78 \% (28/36)$ and by $15.63\%$ in line coverage to $42.58\%$, reflecting the new parsing paths covered in out harness; \texttt{arguments.c}, the file responsible of interpreting command‐line arguments, was increased in this harness too from $5.82\% (45/773)$ to $45.54 \% (352/773)$ and $47.62 \%$ in function coverage; \texttt{cmd.c} rose to $39.14 \%$ of line coverage and $45.45\%$ of function coverage. 
Key-handling routines were now exercised in the new harness as:
\begin{itemize}
    \item \texttt{key-string.c} line coverage rose to $30.00\%$
    \item \texttt{key-bindings} line coverage rose to $56.05\% (278/496)$ 
\end{itemize}

Among individual command modules that were not touched by the previous harness but now are covered by the fuzzer tests:
\begin{itemize}
    \item \texttt{cmd-bind-key.c} and \texttt{cmd-set-options.c} achieved a function coverage of $50.00\%$;
    \item \texttt{cmd-command-prompt.c}, \texttt{cmd-confirm-before.c}, \texttt{cmd-if-shell.c} and \texttt{cmd-confirm-before.c} each reached a function coverage of $25.00\%$;
    \item \texttt{cmd-display-panes.c} and \texttt{cmd-run-shell.c} attained a function coverage of $16.67\%$.    
\end{itemize}
These modules were triggered by inputs passed to the \texttt{cmd\_parse\_from\_arguments} function, corresponding to specific commands that users can issue in tmux to invoke different functionalities.

A further possible improvement for \textit{region B} is to target a broader range of \texttt{cmd-*.c} or other specific command modules files by extending the new harness with additional function calls. This would enable coverage of command-releated operations involving windows, layouts, or panes for example. While such files are not invoked automatically by the new harness, executing the fuzzer for an extended period of time (as common done in research and industry scenarios) could further enhance the overall project coverage and include such code area too.

\section*{Part 4: Crash Analysis}

During the course of this project, efforts were made to uncover new vulnerabilities in \texttt{tmux} using the improved fuzzing harnesses developed in Part 3. Unfortunately, within the allocated fuzzing timeframe, no new crashes indicative of distinct bugs were discovered by our updated fuzzers.

As per the assignment guidelines, in the absence of a newly found bug, this section will focus on the reproduction and detailed analysis of a known, pre-existing vulnerability in \texttt{tmux}. For this purpose, we have chosen to create a proof of concept for and triage \href{https://www.cve.org/CVERecord?id=CVE-2020-27347}{CVE-2020-27347}. The following subsections detail our approach to reproducing this vulnerability and an analysis of its root cause, the implemented fix, and its security implications.

\subsection*{Vulnerability Overview: CVE-2020-27347}

CVE-2020-27347 is a high-severity (CVSS v3.x score 7.8) stack-based buffer overflow vulnerability in {\texttt{tmux}} versions prior to 3.1c (specifically affecting 2.9 through 3.1b) \cite{CVE-2020-27347}. The flaw exists in the \texttt{input\_csi\_dispatch\_sgr\_colon()} function within \texttt{input.c}, which parses colon-separated SGR escape sequences. An attacker with local access, capable of writing to a {\texttt{tmux}} pane, can trigger the overflow by sending a crafted SGR sequence with excessive or malformed empty parameters and can crash the \texttt{tmux} server (causing \textit{Denial of Service}).

\subsection*{Proof of Concept (PoC) and Reproduction}

A reproducible PoC was developed using the bash script \texttt{run\_poc.sh}. This script leverages \texttt{test\_vulnerable.sh}, \texttt{test\_fixed.sh}, and \texttt{run\_tmux\_cve\_test.sh} to execute tests within a Dockerized \href{https://hub.docker.com/layers/library/ubuntu/22.04/images/sha256-a76d0e9d99f0e91640e35824a6259c93156f0f07b7778ba05808c750e7fa6e68}{\texttt{ubuntu:22.04}} environment.

\paragraph{Test Approach:}
The \texttt{run\_poc.sh} script automates the testing by:

\begin{enumerate}
	\item Building a Docker image with \texttt{tmux} build dependencies and the \texttt{tmux} source code cloned from GitHub.
	\item Running tests for a vulnerable and patched version of \texttt{tmux} in isolated container instances.
\end{enumerate}

\paragraph{Per-Version Test Steps:}
\begin{enumerate}
	\item \textbf{Version Checkout:} The specific \texttt{tmux} versions are checked out using \texttt{git reset --hard <commit\_hash>}:

	      \begin{center}
		      \begin{tabular}{@{}r@{\hspace{1em}}l@{}}
			      \parbox[t]{3cm}{\raggedleft \textbf{version \texttt{3.1b}}:                                                                    \\ (vulnerable)} & commit \href{https://github.com/tmux/tmux/commit/6a33a12}{\texttt{6a33a12}} \\[3.5ex]
			      \textbf{patch}: & commit \href{https://github.com/tmux/tmux/commit/a868bacb46e3c900530bed47a1c6f85b0fbe701c}{\texttt{a868bac}} \\
		      \end{tabular}
	      \end{center}

	      Version \texttt{3.1b} (commit \texttt{6a33a12}) is used to demonstrate the vulnerability. The fix is verified using commit \texttt{a868bac}, which introduced the patch and is included in version \texttt{3.1c} and later.

	\item \textbf{Compilation:} \texttt{tmux} is compiled from source using:

	      \noindent \begin{lstlisting}[language=bash, caption=Bash to compile tmux from source, label=lst:tmux-compile]
sh autogen.sh && ./configure && make -j"$(nproc)"
\end{lstlisting}


	\item \textbf{\texttt{tmux} Launch:} A detached \texttt{tmux} session with a unique name is started using the bash command in \autoref{lst:tmux-new-session}. This is done to ensure reliable startup in the scripted environment.

	      \noindent \begin{lstlisting}[language=bash, caption=Bash to create a new detached tmux sesssion, label={lst:tmux-new-session}]
tmux new-session -d -s cve_test_session_<PID>
\end{lstlisting}

	\item \textbf{Target Identification:} The script waits for the session to be ready and identifies the target pane's TTY path using the \texttt{tmux list-panes} utility.

	\item \textbf{Payload Delivery:} The SGR escape sequence reported in \autoref{lst:tmux-payload-delivery} is written directly to the identified pane TTY to trigger the vulnerability. This simulates a user typing the sequence into the \texttt{tmux} pane.

	      \begin{lstlisting}[language=bash, caption=Payload sent to the tmux pane, label={lst:tmux-payload-delivery}]
\033[::::::7::1:2:3::5:6:7:m
\end{lstlisting}

	\item \textbf{Observation \& Verification:} After an observation period (e.g., 10 seconds where the script sleeps waiting for a result), the script checks if the \texttt{tmux} session and server are still responsive (\texttt{tmux has-session}, \texttt{tmux ls}). The outcome is compared against the expected behavior (\emph{crash} in version \texttt{3.1b}, \emph{no crash} after the patch).

	\item \textbf{Cleanup:} Both the tmux test session created earlier and the tmux server are terminated.
\end{enumerate}

This setup consistently reproduces the crash on the vulnerable version and confirms its absence after applying the patch.

\subsubsection*{Root Cause Analysis}

The vulnerability is due to a stack-based buffer overflow within the \texttt{input\_csi\_dispatch\_sgr\_colon()} function in \texttt{input.c}. This function parses SGR escape sequences that can contain colon-separated numerical parameters (e.g., for specifying 24-bit colors). The PoC payload (refer to \autoref{lst:tmux-payload-delivery}) provides a series of parameters, many of which are empty. The function correctly identifies empty parameters but, prior to the fix, would increment its parameter counter for each one without sufficiently checking if this count exceeded the allocated size of a local integer array (\texttt{p[8]}) used to store these parsed parameters. With enough empty parameters, the counter \texttt{n} would exceed the array's bounds. Subsequent attempts to write to or read from \texttt{p[n-1]} would then occur out-of-bounds on the stack, leading to the overflow.

\begin{figure*}[t] 
\centering
	\begin{lstlisting}[language=C, caption=Vulnerable logic simplified: Stack buffer overflow in empty SGR parameter handling, label={lst:vulnerable-sgr-simplified}]
static void input_csi_dispatch_sgr_colon(...)
{
    /* ... variable declarations and setup ... */
    int p[8];          // Fixed-size stack buffer
    u_int n = 0;       // Parameter count/index

    /* consume escape sequence column by column */
    char *ptr;
    ptr = xstrdup(s);
    while ((out = strsep(&ptr, ":")) != NULL) {
        if (*out != '\0') { // Handle non-empty parameter
            p[n++] = strtonum(out, 0, INT_MAX, &errstr);
            ...
        } else { // Handle empty parameter string ("")
            n++; // VULNERABLE: Increment parameter count for an empty parameter

            // !! MISSING BOUNDS CHECK HERE !!
            // not checking if 'n' exceeds the size of 'p'
        }

        // If 'n' was incremented past nitems(p) in the 'else' above,
        // accessing p[n-1] here (or other uses of p/n later) causes an out-of-bounds access.

        /* read buffer 'p' at index 'n-1' */
        log_debug("%s: %u = %d", __func__, n - 1, p[n - 1]);

        ... other code processing parameters using 'p' and 'n' ...
    }
    ... rest of function and cleanup ...
}
\end{lstlisting}
\end{figure*}

\subsubsection*{Fix Discussion}
\label{ssec:fix_cve_2020_27347}

The vulnerability was fixed in \texttt{tmux 3.1c} by commit \href{https://github.com/tmux/tmux/commit/a868bacb46e3c900530bed47a1c6f85b0fbe701c}{\texttt{a868bac}}. The patch modifies the \texttt{input\_csi\_dispatch\_sgr\_colon()} function within \texttt{input.c} by introducing an explicit bounds check -- effectively \texttt{if (n == nitems(p))} -- to ensure that the number of parsed SGR sub-parameters \texttt{n} does not exceed the capacity of the buffer \texttt{p}. If the limit is reached, the function stops processing further parameters from that sequence, preventing the overflow.

\begin{lstlisting}[language=C, caption=Fixed logic: Bounds check added to prevent stack buffer overflow in else statement, label={lst:fixed-sgr-simplified}]
  ...
  } else {
    n++;
    if (n == nitems(p)) {
        free(copy);
        return;
    }
  }
  ...
\end{lstlisting}

\subsubsection*{Security Implication and Severity}
\label{ssec:implications_cve_2020_27347}

The high-severity {\texttt{tmux}} vulnerability \cite{CVE-2020-27347} (CVSS v3.x score 7.8) is a stack-based buffer overflow. The memory corruption crash can lead to \textit{Denial of Service}: a crash of the \texttt{tmux} server process causes the termination of all user sessions managed by the server.
The vulnerability requires local access, specifically the ability of an attacker to write in a \texttt{tmux} pane.

\printbibliography

\end{document}
